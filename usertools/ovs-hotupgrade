#!/bin/sh
active_pid="/usr/local/var/run/openvswitch/ovs-vswitchd-active.pid"
active_log="/var/log/openvswitch/ovs-vswitchd-active.log"

backup_pid="/usr/local/var/run/openvswitch/ovs-vswitchd-backup.pid"
backup_log="/var/log/openvswitch/ovs-vswitchd-backup.log"

br_name="br-dpdk"
ovs_conf="/etc/openvswitch/ovs-dpdk.conf"

host_ip=""
ipam_conf=""
interface=""
interval=0

date=`date +"%Y-%m-%d--%H:%m:%S"`
log_file="/usr/local/var/log/openvswitch/ovs-hotupgrade-${date}.log"
pid_file="/var/run/ovs-hotup.pid"

#Stress test status
stest=1

#prapare,upgrade,finish
curr_stage="prepare"

function log(){
    info=$1
    date=`date +"%Y-%m-%d--%H:%m:%S"`
    echo "${date}-[${FUNCNAME[1]}:${BASH_LINENO[2]}]  $info" >> $log_file
}

function log_echo(){
    info=$1
    date=`date +"%Y-%m-%d--%H:%m:%S"`
    echo "${date}-[${FUNCNAME[1]}:${BASH_LINENO[2]}]  $info" >> $log_file
    echo "$info"
}

function env_init(){    
    curr_prefix=`ovs-vsctl --no-wait get Open_vSwitch . other_config:dpdk-extra|gawk '{print $2}'|sed 's/\"//g'`

    if [ "$curr_prefix" == "ovs-active" ];then
        curr_log="$active_log"
        curr_pid="$active_pid"
        curr_vf1=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '1p'`
        #curr_vf2=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '3p'`
        curr_dpid=`ovs-vsctl --no-wait --if-exists get bridge ${br_name} datapath_id|sed 's/\"//g'`
        curr_mode="active"

        next_log="$backup_log"
        next_pid="$backup_pid"
        next_vf1=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '2p'`
        #next_vf2=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '4p'`
        next_dpid=`ovs-vsctl --no-wait --if-exists get bridge ${br_name} datapath_id|sed 's/\"//g' | rev`
        next_prefix="ovs-backup"
        next_mode="backup"

    elif [ "$curr_prefix" == "ovs-backup" ];then
        curr_log="$backup_log"
        curr_pid="$backup_pid"
        curr_vf1=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '2p'`
        #curr_vf2=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '4p'`
        curr_dpid=`ovs-vsctl --no-wait --if-exists get bridge ${br_name} datapath_id|sed 's/\"//g'`
        curr_mode="backup"

        next_log="$active_log"
        next_pid="$active_pid"
        next_vf1=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '1p'`
        #next_vf2=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '3p'`
        next_dpid=`ovs-vsctl --no-wait --if-exists get bridge ${br_name} datapath_id|sed 's/\"//g'| rev`
        next_prefix="ovs-active"
        next_mode="active"
    fi
    
    curr_ovs_pid=`cat $curr_pid`
    next_ovs_pid=0
    curr_stage="prepare"
    log "curr status curr_prefix $curr_prefix curr_log $curr_log curr_ovs_pid $curr_ovs_pid curr_vf1 $curr_vf1 curr_dpid $curr_dpid curr_mode $curr_mode"
    log "next status next_prefix $next_prefix next_log $next_log next_ovs_pid $next_ovs_pid next_vf1 $next_vf1 next_dpid $next_dpid next_mode $next_mode"
}

curr_prefix=`ovs-vsctl --no-wait get Open_vSwitch . other_config:dpdk-extra|gawk '{print $2}'|sed 's/\"//g'`

if [ "$curr_prefix" == "ovs-active" ];then
    curr_log="$active_log"
    curr_pid="$active_pid"
    curr_vf1=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '1p'`
    #curr_vf2=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '3p'`
    curr_dpid=`ovs-vsctl --no-wait --if-exists get bridge ${br_name} datapath_id|sed 's/\"//g'`
    curr_mode="active"
    
    next_log="$backup_log"
    next_pid="$backup_pid"
    next_vf1=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '2p'`
    #next_vf2=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '4p'`
    next_dpid=`ovs-vsctl --no-wait --if-exists get bridge ${br_name} datapath_id|sed 's/\"//g' | rev`
    next_prefix="ovs-backup"
    next_mode="backup"
    
elif [ "$curr_prefix" == "ovs-backup" ];then
    curr_log="$backup_log"
    curr_pid="$backup_pid"
    curr_vf1=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '2p'`
    #curr_vf2=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '4p'`
    curr_dpid=`ovs-vsctl --no-wait --if-exists get bridge ${br_name} datapath_id|sed 's/\"//g'`
    curr_mode="backup"
    
    next_log="$active_log"
    next_pid="$active_pid"
    next_vf1=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '1p'`
    #next_vf2=`lspci|grep  Virtual | gawk '{print $1}' | sed -n '3p'`
    next_dpid=`ovs-vsctl --no-wait get bridge ${br_name} datapath_id|sed 's/\"//g' | rev`
    next_prefix="ovs-active"
    next_mode="active"
fi

ovsdb_pid=`ps -ax |grep ovsdb-server |grep -v "grep"| grep -v "monitoring"|gawk '{print $1}'`
curr_ovs_pid=`cat $curr_pid`
next_ovs_pid=0

log "curr status curr_prefix $curr_prefix curr_log $curr_log curr_ovs_pid $curr_ovs_pid curr_vf1 $curr_vf1 curr_dpid $curr_dpid curr_mode $curr_mode"
log "next status next_prefix $next_prefix next_log $next_log next_ovs_pid $next_ovs_pid next_vf1 $next_vf1 next_dpid $next_dpid next_mode $next_mode"

function ipam_lock(){
    rst=$(curl -H "Content-Type:application/json" -o /dev/null -X POST -w %{http_code} -s -d '{"host_lock":{"host": "'${host_ip}'", "expiration":600}}' http://${ipam_conf}/v1.0/host/lock)
    if [ $rst -eq 201 ];then
        log "Host $host_ip has been lock by ipam ${ipam_conf}, rst $rst"
    else
        log_echo "Host $host_ip can not lock by ipam ${ipam_conf}, rst $rst"
        return 1
    fi
}

function ipam_unlock(){
    rst=$(curl -X  DELETE -o /dev/null -s -w %{http_code} http://${ipam_conf}/v1.0/host/lock/$host_ip)
    if [ $rst -eq 200 ];then
        log "Host $host_ip has been unlock by ipam ${ipam_conf}"
    else
        log_echo "Host $host_ip has been unlock by ipam ${ipam_conf}, Please try to use \"curl -X DELETE http://${ipam_conf}/v1.0/host/lock/$host_ip\" to unlock it"
        return 1
    fi
}

#Add veth pairs bak
function add_veth_bak(){
    ns_cnt=`ip netns list |wc -l`
    log "Max namespace cnt $ns_cnt"
    
    i=1
    while [ $i -le $ns_cnt ];do
        ns_id=`ip netns list | gawk '{print $3}'| gawk -F ')' '{print $1}'|sed -n "${i}p"`
        ns_name=`ip netns list | gawk '{print $1}'|sed -n "${i}p"`
        log "namespace $ns_name id $ns_id"
        i=`expr  $i + 1`
        
        mac=`ovs-vsctl --no-wait --if-exists get interface outer${ns_id} external_ids:attached-mac|sed 's/\"//g'`
        iface_id=`ovs-vsctl --no-wait --if-exists get interface outer${ns_id} external_ids:iface-id|sed 's/\"//g'`
        subid=`ovs-vsctl --no-wait --if-exists get interface outer${ns_id} external_ids:subnet-id|sed 's/\"//g'`
        vni=`ovs-vsctl --no-wait --if-exists get interface outer${ns_id} external_ids:vni|sed 's/\"//g'`
        
        log "port outer${ns_id} mac $mac ifaceid $ifaceid subid $subid vni $vni"
        
        [ -z "$mac" ] || [ -z "$iface_id" ] || [ -z "$subid" ] || [ -z "$vni" ] && log "No veth pair with namespace $ns_name id $ns_id" && continue
        
        ip link add outer${ns_id}-bak type veth peer name inner${ns_id}-bak
        [ $? -ne 0 ] && log_echo "add veth outer${ns_id}-bak pair error" && continue
        ip link set outer${ns_id}-bak up
        [ $? -ne 0 ] && log_echo "set port outer${ns_id}-bak up error" && continue
        ip link set inner${ns_id}-bak netns $ns_name
        [ $? -ne 0 ] && log_echo "set inner${ns_id}-bak netns $ns_name error" && continue
        ip netns exec $ns_name ip link set inner${ns_id}-bak up
        [ $? -ne 0 ] && log_echo "exec $ns_name ip link set inner${ns_id}-bak up error" && continue
        ip netns exec $ns_name brctl addif br-netns inner${ns_id}-bak
        [ $? -ne 0 ] && log_echo "exec $ns_name brctl addif br-netns inner${ns_id}-bak error" && continue
        ovs-vsctl --no-wait --may-exist add-port ${br_name} outer${ns_id}-bak -- set interface outer${ns_id}-bak type=system
        [ $? -ne 0 ] && log_echo "add-port ${br_name} outer${ns_id}-bak error" && continue
        new_iface=`ovs-vsctl --no-wait get interface outer${ns_id}-bak _uuid`
        ovs-vsctl --no-wait --if-exists set interface outer${ns_id}-bak external_ids:vni=$vni external_ids:subnet-id=$subid external_ids:attached-mac=$mac external_ids:iface-id=$new_iface
        [ $? -ne 0 ] && log_echo "set interface outer${ns_id}-bak error" && continue
        ovs-vsctl --no-wait --if-exists del-port outer${ns_id}
        [ $? -ne 0 ] && log_echo "del port outer${ns_id} error" && continue
        log "namespace $ns_name id $ns_id add veth pair backup successfully"
    done
}

# Delete veth bak pairs
function delete_veth_bak(){
    ns_cnt=`ip netns list |wc -l`
    i=1
    while [ $i -le $ns_cnt ];do
        ns_id=`ip netns list | gawk '{print $3}'| gawk -F ')' '{print $1}'|sed -n "${i}p"`
        ns_name=`ip netns list | gawk '{print $1}'|sed -n "${i}p"` 
        i=`expr  $i + 1`
        
        mac=`ovs-vsctl --no-wait --if-exists get interface outer${ns_id}-bak external_ids:attached-mac|sed 's/\"//g'`
        subid=`ovs-vsctl --no-wait --if-exists get interface outer${ns_id}-bak external_ids:subnet-id|sed 's/\"//g'`
        vni=`ovs-vsctl --no-wait --if-exists get interface outer${ns_id}-bak external_ids:vni|sed 's/\"//g'`
        log "port outer${ns_id} mac $mac subid $subid vni $vni"
        
        [ -z "$mac" ] || [ -z "$subid" ] || [ -z "$vni" ] && log "No veth pair with namespace $ns_name id $ns_id" && continue
        
        log "ns $ns_name id $ns_id is going to delete veth pair backup"
        ovs-vsctl --no-wait --may-exist add-port ${br_name} outer${ns_id} -- set interface outer${ns_id} type=system
        [ $? -ne 0 ] && log_echo "add-port ${br_name} outer${ns_id} error" && continue
        new_iface=`ovs-vsctl --no-wait --if-exists get interface outer${ns_id} _uuid`
        ovs-vsctl --no-wait --if-exists set interface outer${ns_id} external_ids:vni=$vni external_ids:subnet-id=$subid external_ids:attached-mac=$mac external_ids:iface-id=$new_iface
        [ $? -ne 0 ] && log_echo "set interface outer${ns_id} error" && continue
        ovs-vsctl --no-wait --if-exists del-port outer${ns_id}-bak
        [ $? -ne 0 ] && log_echo "del-port outer${ns_id}-bak error" && continue
        ip link del outer${ns_id}-bak
        [ $? -ne 0 ] && log_echo "del outer${ns_id}-bak error" && continue
        log "ns $ns_name id $ns_id delete veth pair backup finsihed"
    done
}

#Check sys env is normal
function sys_env_check(){
    vfcnt=`lspci |grep  Virtual | gawk '{print $1}'|wc -l`
    if [ $vfcnt -ne 2 ];then
        log_echo "Error vf count is $vfcnt"
        return 1
    fi
    
    bind_vf=`dpdk-devbind -s | grep "Virtual Function" |grep drv=vfio-pci | grep "${curr_vf1}" |gawk '{print $1}'`
    if [ -z "$bind_vf" ];then
        log_echo "Vf pci $bind_vf should bind by vfio-pci"
        return 1
    fi
    
    unbind_vf=`dpdk-devbind -s |grep "Virtual Function" | grep drv=vfio-pci |grep "${next_vf1}"|gawk '{print $1}'`
    if [ -n "$unbind_vf" ];then
        log_echo "Vf pci $unbind_vf cannot bind by vfio-pci"
        return 1
    fi
    
    log "curr status curr_prefix $curr_prefix curr_log $curr_log curr_ovs_pid $curr_ovs_pid curr_vf1 $curr_vf1 curr_dpid $curr_dpid curr_mode $curr_mode"
    log "next status next_prefix $next_prefix next_log $next_log next_ovs_pid $next_ovs_pid next_vf1 $next_vf1 next_dpid $next_dpid next_mode $next_mode"
    
    [ -z "$curr_prefix" ] || [ -z "$curr_log" ] || [ -z "$curr_ovs_pid" ] || [ -z "$curr_vf1" ] || [ -z "$curr_dpid" ] ||  [ -z "$curr_mode" ] && log_echo "Curr env init error" && return 1
    [ -z "$next_prefix" ] || [ -z "$next_log" ] || [ -z "$next_ovs_pid" ] || [ -z "$next_vf1" ] ||  [ -z "$next_dpid" ] ||  [ -z "$next_mode" ] && log_echo "Next env init error" && return 1
    
    if [ -f $pid_file ];then
        upgrade_pid=`cat ${pid_file}`
        log_echo "Another $_pname is running with pid $upgrade_pid"
        return 1
    fi
    
    free_huge=`cat /sys/kernel/mm/hugepages/hugepages-2048kB/free_hugepages`
    if [ $free_huge -lt 1024 ];then
        log_echo "No enough free hugepage is system, ovs new process need 1024, the free is $free_huge"
        return 1
    fi
    
    if [ ! -e $ovs_conf ];then
        log_echo "Ovs configuration file \"$ovs_conf\" is not exist"
        return 1
    fi
    
    if [ $curr_ovs_pid -eq 0 ];then
        log_echo "There is no ovs-vswitchd process running"
        return 1
    fi
        
    if [ -z "$ovsdb_pid" ];then
        log_echo "There is no ovsdb-server process running"
        return 1
    fi
}

# Check the cmd execute 
function check_stage(){
    stg=$1
    if [ $stg != $curr_stage ];then
        log_echo "Error cmd, Must be executed in order \"prepare upgrade finsish\""
        return 1
    fi
    return 0
}

#Prepare configuration before upgrade 
function prepare_upgrade(){
    check_stage "prepare"
    [ $? -ne 0 ] && return 1
    
    [ -z "$host_ip" ] || [ -z "$ipam_conf" ] || [ -z "$interface" ] && echo "host_ip ipam_conf host_port interface must be set before upgrade" && return 1

    log "Starting ovs hot upgrade prepare process"

    ipam_lock
    [ $? -ne 0 ] && return 1
    
    ovs-vsctl --no-wait set Open_vSwitch . other_config:cpu-yield=true
    log "Set cpu-yield=true"

    ovs-appctl  -t /usr/local/var/run/openvswitch/ovs-vswitchd.${curr_ovs_pid}.ctl  ovsdb-tool/auto-reconnect true >> /dev/null
    [ $? -ne 0 ] && log_echo "set $curr_ovs_pid ovsdb-tool/auto-reconnect true error" && return 1
    
    ovs-vsctl --no-wait set Open_vSwitch . other_config:vhostuser-no-autoconnect=true
    log "Set vhostuser-no-autoconnect=true"
    
    ovs-appctl  -t /usr/local/var/run/openvswitch/ovs-vswitchd.${curr_ovs_pid}.ctl  ovsdb-tool/auto-reconnect false >> /dev/null
    [ $? -ne 0 ] && log_echo "set $curr_ovs_pid ovsdb-tool/auto-reconnect false error" && return 1
    
    ovs-appctl -t ovsdb-server ovsdb-server/reconnect
    [ $? -ne 0 ] && log_echo "set $curr_ovs_pid ovsdb-server/reconnect error" && return 1
    log "The ovs-vswitchd ${curr_ovs_pid} has disconnect the ovsdb"
    
    dpdk-devbind -b vfio-pci 0000:$next_vf1 >> /dev/null
    ovs-vsctl --no-wait set interface dpdk1 options:dpdk-devargs=0000:$next_vf1
    [ $? -ne 0 ] && log_echo "set $pid dpdk-devargs=0000:$next_vf1 error" && return 1
    #ovs-vsctl --no-wait set interface dpdk2 options:dpdk-devargs=0000:$next_vf2
    #[ $? -ne 0 ] && log_echo "set $pid dpdk-devargs=0000:$next_vf2 error" && return
    
    log "Vf has been set to $next_vf1"
    
    ovs-vsctl --no-wait set bridge ${br_name} datapath_id=$next_dpid
    ovs-vsctl --no-wait set bridge ${br_name} other_config:datapath-id=$next_dpid
    [ $? -ne 0 ] && log_echo "set bridge datapath-id=$next_dpid error" && return 1
    log "set bridge datapath-id=$next_dpid"
    ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-extra="--file-prefix $next_prefix"
    log "set --file-prefix $next_prefix"
    
    sed -ie 's/OVS_MODE=\"$curr_mode\"/OVS_MODE=\"$next_mode\"/g' $ovs_conf
    log "The $ovs_conf OVS_MODE has been change from $curr_mode to $next_mode"
    
    add_veth_bak
    
    curr_stage="upgrade"
    
    log "Ovs hot upgrade prepare process has finished"
}

#Swap vhostuser to new ovs process
function swap_vhost_user(){
    new_pid=$1
    exe_port=$2
    
    log "parameter new_pid $new_pid, exe_port $exe_port"
    port_cnt=`ovs-vsctl show |grep -B 1 dpdkvhostuserclient|grep Interface |gawk '{print $2}'|sed 's/\"//g' | wc -l`
    log "port_cnt $port_cnt"
    
    i=1
    k=0
    while [ $i -le $port_cnt ];do
        port=`ovs-vsctl show |grep -B 1 dpdkvhostuserclient|grep Interface |gawk '{print $2}'|sed 's/\"//g'|sed -n "${i}p"`
        i=`expr  $i + 1`
        if [[ "$exe_port" == "all" || "$exe_port" == "$port" ]];then
            mac=`ovs-vsctl --no-wait  --if-exists get interface $port external_ids:attached-mac|sed 's/\"//g'|tr 'a-z' 'A-Z'`
            vni=`ovs-vsctl --no-wait  --if-exists get interface $port external_ids:vni|sed 's/\"//g'`
            [ -z "$mac" ] || [ -z "$vni" ] && log_echo "Get port $port mac $mac; vni $vni error, swap error" && continue
            log "port $port mac $mac; vni $vni is starting to swap"
            
            didicloud_filter del $vni $mac 
            [ $? -ne 0 ] && log_echo "port $port didicloud_filter del $vni $mac error"
            didicloud_filter add $vni $mac &
            [ $? -ne 0 ] && log_echo "port $port didicloud_filter add $vni $mac error" && continue
            
            ovs-appctl -t /usr/local/var/run/openvswitch/ovs-vswitchd.${new_pid}.ctl netdev-dpdk/reconnect $port >> /dev/null &
            if [ $? -eq 0 ];then
                log_echo "Port $port has swap to vswitch $new_pid"
            else
                log_echo "Port $port swap to vswitch $new_pid ERROR"
            fi
            k=1
        fi
        if [ $2 == "all" ];then
            sleep 1
        fi
    done
    
    if [ $k -eq 0 ] && [ $2 != "all" ];then
        log_echo "Port $exe_port cannot be found"
    fi
}

#The upgrade process function
function upgrade_vhost_user(){
    check_stage "upgrade"
    [ $? -ne 0 ] && return 1
    exe_port=$1
    [ -z "$exe_port" ] && log_echo "Must input a port name or all" && return 1
    
    log "Starting ovs hot upgrade process"
    
    if [ $next_ovs_pid -eq 0 ];then
        ovs-vswitchd --pidfile=$next_pid --log-file=$next_log --monitor --detach -vconsole:emer -vsyslog:err -vfile:info --mlockall --no-chdir >> /dev/null
        next_ovs_pid=`cat $next_pid`
        [ $next_ovs_pid -eq 0 ] && log_echo "New ovs-vswithd process start error" && return 1

        log_echo "New ovs-vswithd process $next_ovs_pid has been start up"
        ovs-vsctl --no-wait set bridge ${br_name} other_config:datapath-id=$next_dpid
        [ $? -ne 0 ] && log_echo "set bridge datapath-id=$next_dpid error" && return 1
        log "set bridge datapath-id=$next_dpid"
        sleep 5
    fi
    
    log "new_pid $next_ovs_pid"

    swap_vhost_user $next_ovs_pid $exe_port
    
    log "Ovs hot upgrade process has finished"
    curr_stage="finish"
    
}

#Cleanup all configuration after upgrade success
function upgrade_over(){
    check_stage "finish"
    [ $? -ne 0 ] && return 1
    
    log "starting ovs hot upgrade over process"
    ovs-appctl  -t /usr/local/var/run/openvswitch/ovs-vswitchd.${curr_ovs_pid}.ctl  exit
    [ $? -ne 0 ] && log_echo "Ovs-vswithd $curr_ovs_pid exit error" && return 1
    
    dpdk-devbind -u 0000:$curr_vf1 >> /dev/null
    
    delete_veth_bak
    
    ovs-vsctl --no-wait set Open_vSwitch . other_config:vhostuser-no-autoconnect=false
    log "Set vhostuser-no-autoconnect=false"
    ovs-vsctl --no-wait set Open_vSwitch . other_config:cpu-yield=false
    log "Set cpu-yield=false"
    ipam_unlock
    [ $? -ne 0 ] && return 1
    
    rm -fr /dev/hugepages/${curr_prefix}*
    log "Ovs hot upgrade process has finished"
    
    env_init
    curr_stage="prepare"
}

# Reset the configuration to the status before upgrade
function reset_env(){
    if [ $next_ovs_pid -ne 0 ];then  
        ovs-appctl  -t /usr/local/var/run/openvswitch/ovs-vswitchd.${next_ovs_pid}.ctl  ovsdb-tool/auto-reconnect false >> /dev/null
        [ $? -ne 0 ] && log_echo "set $curr_ovs_pid ovsdb-tool/auto-reconnect true error" && return 1

        ovs-appctl -t ovsdb-server ovsdb-server/reconnect
        [ $? -ne 0 ] && log_echo "set $curr_ovs_pid ovsdb-server/reconnect error" && return 1
        log "The ovs-vswitchd ${curr_ovs_pid} has disconnect the ovsdb"
    fi
    
    ovs-vsctl --no-wait  set interface dpdk1 options:dpdk-devargs=0000:$curr_vf1
    [ $? -ne 0 ] && log_echo "reset_env" "set $curr_ovs_pid dpdk-devargs=0000:$curr_vf1 error" && return 1
    #ovs-vsctl --no-wait  set interface dpdk2 options:dpdk-devargs=0000:$curr_vf2
    #[ $? -ne 0 ] && log_echo "reset_env" "set $curr_ovs_pid dpdk-devargs=0000:$curr_vf2 error" && return
    log "Vf has been set to $curr_vf1"
    
    if [ $next_ovs_pid -ne 0 ];then
        swap_vhost_user $curr_ovs_pid "all"
    fi
    
    if [ $next_ovs_pid -ne 0 ];then  
        ovs-appctl  -t /usr/local/var/run/openvswitch/ovs-vswitchd.${next_ovs_pid}.ctl  exit
        [ $? -ne 0 ] && log_echo "ovs-vswitchd $next_ovs_pid exit error" && return 1
        log "ovs-vswitchd $next_ovs_pid has exit"
        next_ovs_pid=0
        rm -fr /dev/hugepages/${next_prefix}*
        sleep 1    
    fi
    
    dpdk-devbind -u 0000:$next_vf1 >> /dev/null
    dpdk-devbind -b vfio-pci 0000:$curr_vf1 >> /dev/null
    
    ovs-vsctl --no-wait set bridge ${br_name} other_config:datapath-id=$curr_dpid
    [ $? -ne 0 ] && log_echo "set bridge datapath-id=$curr_dpid error" && return 1
    log "set bridge datapath-id=$curr_dpid"
    
    ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-extra="--file-prefix $curr_prefix"
    mode_str=`grep OVS_MODE $ovs_conf`
    sed -ie 's/${mode_str}/OVS_MODE=\"$curr_mode\"/g' $ovs_conf
    log "ovs-prefix has been set to active"
    
    delete_veth_bak

    ovs-vsctl --no-wait set Open_vSwitch . other_config:vhostuser-no-autoconnect=false
    log "Set vhostuser-no-autoconnect=false"
    ovs-vsctl --no-wait set Open_vSwitch . other_config:cpu-yield=false
    log "Set cpu-yield=false"
    ovs-appctl  -t /usr/local/var/run/openvswitch/ovs-vswitchd.${curr_ovs_pid}.ctl  ovsdb-tool/auto-reconnect true >> /dev/null
    [ $? -ne 0 ] && log_echo "set $curr_ovs_pid ovsdb-tool/auto-reconnect true error" && return 1
    
    ipam_unlock
    [ $? -ne 0 ] && return 1
    curr_stage="prepare"
}

function all_process(){
    prepare_upgrade
    [ $? -ne 0 ] && log "prepare_upgrade error" && return 1
    upgrade_vhost_user "all"
    [ $? -ne 0 ] && log "upgrade_vhost_user error" && return 1
    upgrade_over
    [ $? -ne 0 ] && log "upgrade_over error" && return 1
}

function all_process_with_reset(){
    prepare_upgrade
    [ $? -ne 0 ] && log "prepare_upgrade error" && reset_env && return 1
    upgrade_vhost_user "all"
    [ $? -ne 0 ] && log "upgrade_vhost_user error" && reset_env && return 1
    upgrade_over
    [ $? -ne 0 ] && log "upgrade_over error" && reset_env && return 1
}

function usage(){
    echo "USAGE: " 
    echo "prepare                               Prepare the upgrade configuration"
    echo "upgrade <port>                        Upgrade one or all vhostuser port"
    echo "finish                                End the hot upgrade process and set the old ovs-switchd exit"
    echo "reset                                 Reset the env to the status before upgrade when some error happens"
    echo "all                                   Include prepare upgrade finish,and swap all vhostuser"
    echo "help                                  Show the usage"
    echo "show config                           Show the configuration"
    echo "show status                           Show the current status"
    echo "show vhostuser                        Show all vhostuser port name"
    echo "show log <line>                       Show log info, <all>:show all log of this hotupgrade"
    echo "set host_ip <ip>                      Set the host ip address"
    echo "set ipam_conf <ip:port>               Set the ipam ip address and port"
    echo "set interface <interface>             Set the interface name of the bond"
    echo "reinit                                Reinit the env, only can be executed after one hot upgrade finish"
    echo "stress_test <interval>                Do stress_test, <interval>: the upgrade interval(300~3600)sï¼Œ default is 300s"
    echo "exit | quit                           Quit this process"
}

function usage_detach(){
    echo "USAGE: "
    echo "   -i        System data interface name"
    echo "   -h        System data interface ip address"
    echo "   -p        Ipam conf, ipaddress:port"
    echo "   -t        Stress test interval(300-3600)s"
}

function show_log(){
    line=$1
    if [ "$line" == "all" ];then
        more $log_file
    elif [[ "$line" =~ "^[0-9]+$" ]];then
        tail -$line $log_file
    else
        tail -10 $log_file
    fi
}

function show_vhostuser(){
    ovs-vsctl show |grep -B 1 dpdkvhostuserclient|grep Interface |gawk '{print $2}'|sed 's/\"//g'
}

function show_status(){
    log_echo "      Current Ovs Pid:        $curr_ovs_pid"
    log_echo "       Current prefix:        $curr_prefix"
    log_echo "       Current ovslog:        $curr_log"
    log_echo "          Current vf1:        $curr_vf1"
    #log_echo "          Current vf2:        $curr_vf2"
    log_echo "         Current dpid:        $curr_dpid"
    log_echo "         Current mode:        $curr_mode"
    log_echo "         Next Ovs Pid:        $next_ovs_pid"
    log_echo "          Next prefix:        $next_prefix"
    log_echo "          Next ovslog:        $next_log"
    log_echo "             Next vf1:        $next_vf1"
    #log_echo "             Next vf2:        $next_vf2"
    log_echo "            Next dpid:        $next_dpid"
    log_echo "            Next mode:        $next_mode"
    log_echo "             Log file:        $log_file"
    log_echo "           Curr stage:        $curr_stage"
}

function show_config(){
    log_echo "              host ip:        $host_ip"
    log_echo "            ipam_conf:        $ipam_conf"
    log_echo "            interface:        $interface"
}

function set_key_value(){
    key=$1
    value=$2
    case $key in
        "host_ip")
            host_ip="$value"
            ;;
        "ipam_conf")
            ipam_conf="$value"
            ;;
        "interface")
            interface="$value"
            ;;
        *)
            log_echo "Unkown Key $key, Please use \"help\" to get more info"
            ;;
    esac
}

function show_key_value(){
    key=$1
    case $key in
        "config")
            show_config
            ;;
        "status")
            show_status
            ;;
        "vhostuser")
            show_vhostuser
            ;;
        "log")
            show_log $value
            ;;
        *)
            log_echo "Unkown Key $key, Please use \"help\" to get more info"
            ;;
    esac
} 

function stress_final(){
    stest=0
}

function stress_start(){
    interval=$1
    stest=1
    if [[ "$interval" =~ "^[0-9]+$" ]];then
        if [ $interval -lt 300 ] || [ $interval -gt 3600 ];then
            interval=300
        fi
    elif [ "$interval" == "" ];then
        interval=300
    else
        log_echo "Please input a valid time value(300 ~ 3600)"
        return 1
    fi
    
    show_status
    show_config
    
    while [ 1 ];
    do
        all_process
        env_init
        [ $? -ne 0 ] && log "env_init error" && return 1

        for (( i=1; i<=$interval; i++ ))  
        do    
            if [ $stest -ne 1 ];then
                return 0
            fi
            sleep 1
        done
    done
}

function cmdline(){
    usage

    while [ 1 ];
    do
        echo -e "\E[1;34m<ovs-hotupgrade> \E[0m\c"
        read _process key value

        case $_process in
            "help")
                usage
                ;;
            "set")
                set_key_value $key $value 
                ;;
            "show")
                show_key_value $key 
                ;;
            "prepare")
                prepare_upgrade
                ;;
            "upgrade")
                upgrade_vhost_user $key
                ;;
            "finish")
                upgrade_over
                ;;
            "all")
                all_process
                ;;
            "reset")
                reset_env
                ;;
            "stress_test")
                stress_start $key
                ;;
            "quit" | "exit")
                echo -e "Are you sure to quit the ovs hotupgrade?<YES/NO>\c"
                read yesno
                if [ "$yesno" == "YES" ];then
                    rm -f $pid_file
                    exit
                fi
                ;;
            "")
                ;;
            *)
                log_echo "Unkown Comand $_process, Please use \"help\" to get more info"
                ;;
        esac
    done
}

#main function

#Disable TERM INT HUP signal
trap "" TERM HUP
trap stress_final INT

_pname=$0

if [ "$1" == "--help" ];then
    usage_detach
    exit
fi

sys_env_check
[ $? -ne 0 ] && exit

while getopts "i:h:p:t:" arg
do
    case $arg in
        i)
            interface=$OPTARG
            ;;
        h)
            host_ip=$OPTARG
            ;;
        p)
            ipam_conf=$OPTARG
            ;;
        t)
            interval=$OPTARG
            if [ $interval -lt 300 ] || [ $interval -gt 3600 ];then
                usage_detach
                exit
            fi
            ;;
        *)
            usage_detach
            exit
            ;;
    esac
done 

echo $$ > $pid_file
if [ $# -eq 0 ];then
    cmdline
else
    show_config
    show_status
    while [ 1 ];
    do
        all_process_with_reset
        if [ $interval -eq 0 ];then
            break
        else
            sleep $interval
        fi
    done
fi

rm -f $pid_file
